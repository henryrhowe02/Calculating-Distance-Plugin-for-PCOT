import cv2 as cv
import numpy as np
import glob
import os

# Chessboard parameters
chessboard_size = (9, 6)  # Number of inner corners
square_size = 1.0  # Size of a square in your preferred unit
img_size = (1024, 1024)

# Prepare object points (0,0,0), (1,0,0), (2,0,0) ... (8,5,0)
objp = np.zeros((chessboard_size[0] * chessboard_size[1], 3), np.float32)
objp[:, :2] = np.mgrid[0:chessboard_size[0], 0:chessboard_size[1]].T.reshape(-1, 2)
objp *= square_size  # Scale by square size

# Arrays to store object points and image points
objpoints = []  # 3D points in real world space
imgpoints_left = []  # 2D points in left image plane
imgpoints_right = []  # 2D points in right image plane

# Get image pairs 
duo_left_images = glob.glob(os.path.join('HenryFiles/Camera Calibration/in both images/left images duo', '*.png'))
duo_right_images = glob.glob(os.path.join('HenryFiles/Camera Calibration/in both images/right images duo', '*.png'))

def duo_calibration(left_images, right_images):


    for left_img_path, right_img_path in zip(left_images, right_images):
        left_img = cv.imread(left_img_path)
        right_img = cv.imread(right_img_path)
        
        gray_left = cv.cvtColor(left_img, cv.COLOR_BGR2GRAY)
        gray_right = cv.cvtColor(right_img, cv.COLOR_BGR2GRAY)
        
        # Find chessboard corners
        ret_left, corners_left = cv.findChessboardCorners(gray_left, chessboard_size, None)
        ret_right, corners_right = cv.findChessboardCorners(gray_right, chessboard_size, None)
        
        if ret_left and ret_right:
            # Refine corner positions
            criteria = (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, 30, 0.001)
            corners_left = cv.cornerSubPix(gray_left, corners_left, (11, 11), (-1, -1), criteria)
            corners_right = cv.cornerSubPix(gray_right, corners_right, (11, 11), (-1, -1), criteria)
            
            # Store the points
            objpoints.append(objp)
            imgpoints_left.append(corners_left)
            imgpoints_right.append(corners_right)
            
            # Draw and display the corners (optional)
            cv.drawChessboardCorners(left_img, chessboard_size, corners_left, ret_left)
            cv.drawChessboardCorners(right_img, chessboard_size, corners_right, ret_right)
            # cv.imshow('Left Corners', left_img)
            # cv.imshow('Right Corners', right_img)
            cv.waitKey(1)

    cv.destroyAllWindows()
    return objpoints, imgpoints_left, imgpoints_right

def non_duo_calibration()

# Calibrate each camera individually
ret_left, mtx_left, dist_left, rvecs_left, tvecs_left = cv.calibrateCamera(
    objpoints, imgpoints_left, img_size, None, None)
ret_right, mtx_right, dist_right, rvecs_right, tvecs_right = cv.calibrateCamera(
    objpoints, imgpoints_right, img_size, None, None)

# Stereo calibration
flags = 0
flags |= cv.CALIB_FIX_INTRINSIC
criteria_stereo = (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, 30, 0.001)

ret_stereo, mtx_left, dist_left, mtx_right, dist_right, R, T, E, F = cv.stereoCalibrate(
    objpoints, imgpoints_left, imgpoints_right, 
    mtx_left, dist_left, mtx_right, dist_right, 
    img_size, criteria=criteria_stereo, flags=flags)

# Compute rectification transforms
rect_scale = 1  # Scaling factor: 0=zoomed out, 1=cropped
rect_left, rect_right, proj_left, proj_right, Q, roi_left, roi_right = cv.stereoRectify(
    mtx_left, dist_left, mtx_right, dist_right, img_size, 
    R, T, flags=cv.CALIB_ZERO_DISPARITY, alpha=rect_scale)

# Compute mapping for rectification
map_left_x, map_left_y = cv.initUndistortRectifyMap(
    mtx_left, dist_left, rect_left, proj_left, img_size, cv.CV_32FC1)
map_right_x, map_right_y = cv.initUndistortRectifyMap(
    mtx_right, dist_right, rect_right, proj_right, img_size, cv.CV_32FC1)


# idx = 0
# # Example: Rectify a pair of images
# left_img = cv.imread(left_images[idx])
# right_img = cv.imread(right_images[idx])

# left_img = cv.imread('HenryFiles\AUPE Images\distance\pctset-1m-8bit\distance_pctset-1m-8bit_LWAC01_T00_P00_BS.png')
# right_img = cv.imread('HenryFiles\AUPE Images\distance\pctset-1m-8bit\distance_pctset-1m-8bit_RWAC01_T00_P00_BS.png')

left_img = cv.imread('HenryFiles\AUPE Images\distance\pctset-1m-8bit-tiltdown\distance_pctset-1m-8bit-tiltdown_LWAC01_T00_P00_BS.png')
right_img = cv.imread('HenryFiles\AUPE Images\distance\pctset-1m-8bit-tiltdown\distance_pctset-1m-8bit-tiltdown_RWAC01_T00_P00_BS.png')

left_rectified = cv.remap(left_img, map_left_x, map_left_y, cv.INTER_LINEAR)
right_rectified = cv.remap(right_img, map_right_x, map_right_y, cv.INTER_LINEAR)

# Display rectified images
combined_rectified = np.hstack((left_rectified, right_rectified))

# Draw horizontal lines on combined image
num_lines = 40
interval = combined_rectified.shape[0] // num_lines
for i in range(0, combined_rectified.shape[0], interval):
    cv.line(combined_rectified, (0, i), (combined_rectified.shape[1], i), (0, 255, 0), 1)

cv.namedWindow('Rectified Images', cv.WINDOW_NORMAL)
cv.imshow('Rectified Images', combined_rectified)
cv.waitKey(0)
cv.destroyAllWindows()